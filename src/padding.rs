use rand::{distributions::Uniform, CryptoRng, Rng, SeedableRng};
use std::io::{Error, ErrorKind};

/// Generates a random number between 2 and 32 (inclusive) with the given random number generator.
///
/// # Arguments
///
/// * `rng` - A mutable reference to a random number generator.
///
/// # Returns
///
/// A random u32 between 2 and 32 (inclusive).

fn generate_random_num<R: Rng + CryptoRng>(rng: &mut R) -> u32 {
    let range = Uniform::new_inclusive(2, 32);
    rng.sample(range)
}

/// Generates a vector of random bytes with the specified length, excluding a specific character.
///
/// # Arguments
///
/// * `rng` - A mutable reference to a random number generator.
/// * `count` - The number of bytes to generate.
/// * `exclusion` - The character to exclude from the generated bytes.
///
/// # Returns
///
/// A vector of random bytes with the defined length, excluding the specified character.

fn generate_random_bytes<R: Rng>(rng: &mut R, count: u32, exclusion: char) -> Vec<u8> {
    let mut bytes = Vec::with_capacity(count as usize);

    // Use the random number generator to fill the defined buffer with random bytes.
    let mut buf = [0u8; 256];
    rng.try_fill_bytes(&mut buf)
        .expect("Failed to fill buffer.");

    // Iterate over the buffer to generate random bytes.
    for &byte in &buf {
        // Check if the desired number of bytes has been generated.
        if bytes.len() == count as usize {
            break;
        }

        // Exclude the specified character from the generated bytes
        if byte != exclusion as u8 {
            bytes.push(byte);
        }
    }

    // Return the vector of random bytes.
    bytes
}

/// Encapsulates the given BSON packet with a random number (between 2 and 32 inclusive) of random bytes before and after.
///
/// # Arguments
///
/// * `pkt` - A reference to a BSON packet.
///
/// # Returns
///
/// The encapsulated packet in Vec<u8> form.
///
/// # Errors
///
/// Returns an error if the BSON packet is not valid (it does not start and end with the correct braces) or
/// if there is an error during the generation of random bytes or packet encapsulation

fn encapsulate(pkt: &[u8]) -> Result<Vec<u8>, std::io::Error> {
    // if the packet does not start and end with braces, it is not valid BSON data
    if pkt[0] != b'{' || pkt[pkt.len() - 1] != b'}' {
        return Err(Error::from(ErrorKind::InvalidData));
    }

    let mut rng = rand_chacha::ChaCha8Rng::from_entropy(); // use the ChaCha8Rng algorithm to generate our random numbers and bytes
    let r1 = generate_random_num(&mut rng); // length of random bytes before the BSON data
    let r2 = generate_random_num(&mut rng); // length of random bytes after the BSON data

    // vectors containing the random bytes for the front and back padding of the BSON data
    let front_pad = generate_random_bytes(&mut rng, r1, '{');
    let back_pad = generate_random_bytes(&mut rng, r2, '}');

    // define a new vector to add the front pad, the packet, and finally the back pad
    let mut encapsulated_pkt = Vec::new();
    encapsulated_pkt.extend(front_pad);
    encapsulated_pkt.extend(pkt);
    encapsulated_pkt.extend(back_pad);

    Ok(encapsulated_pkt)
}

/// Strips the padding from an unencrypted packet.
///
/// # Arguments
///
/// * `pkt` - A reference to a BSON packet with randomized padding.
///
/// # Returns
///
/// The revealed BSON in Vec<u8> form if successful.
///
/// # Errors
///
/// Returns an error if the BSON packet is not valid (it does not start and end with the correct braces) or
/// if there is an error during the extraction of BSON data.
fn reveal(pkt: &[u8]) -> Result<Vec<u8>, std::io::Error> {
    let pkt_vec = pkt.to_vec();

    // initialize bson_front_index & bson_back_index with a default of -1 to indicate they hasn't been changed
    let mut bson_front_index: i32 = -1;
    let mut bson_back_index = -1;

    // loop through the packet and find the index of the beginning of the BSON data.
    for (index, &element) in pkt_vec.iter().enumerate() {
        if element == b'{' {
            // if the brace is not within 2-32 (inclusive) bytes, the packet is not valid
            if index < 2 || index > 32 {
                return Err(Error::from(ErrorKind::InvalidData));
            } else {
                bson_front_index = index as i32; // store the index of the bracket for later use
                break;
            }
        }
    }

    // if the bson_front_index hasn't been changed, we were unable to find an open bracket and therefore need to throw an error
    if bson_front_index == -1 {
        return Err(Error::from(ErrorKind::InvalidData));
    }

    // loop through the packet backwards to find the end of the BSON data
    for (rev_index, &element) in pkt_vec.iter().rev().enumerate() {
        if element == b'}' {
            if rev_index < 2 || rev_index > 32 {
                return Err(Error::from(ErrorKind::InvalidData));
            } else {
                let index = pkt_vec.len() - rev_index; // since the index is now reversed, we have to turn it back into the normal index for future use
                bson_back_index = index as i32;
                break;
            }
        }
    }

    // if the bson_back_index hasn't been changed, we were unable to find a closed bracket and therefore need to throw an error
    if bson_back_index == -1 {
        return Err(Error::from(ErrorKind::InvalidData));
    }

    // the revealed packet is just the bytes between the opening bracket and closing bracket (inclusive)
    let revealed_pkt = pkt_vec[bson_front_index as usize..bson_back_index as usize].to_vec();

    Ok(revealed_pkt)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn bson_wrap_unwrap() {
        let pkt = b"{This is sample BSON data}";
        assert_eq!(reveal(&encapsulate(pkt).unwrap()).unwrap(), pkt.to_vec());
    }
}
